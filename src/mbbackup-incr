#!/usr/bin/python 
#Description: Incremental backup

import commands
import os
import sys
import signal
import time
import socket 
import consts 
from logger import Logger
from config import Config
from mc_bin_client import MemcachedClient 

class MembaseBackup:
    def __init__(self):
        self.hostname = socket.gethostname()
        self.hostprefix = '-'.join(self.hostname.split('-')[:-1])
        self.backup_file = ''
        signal.signal(signal.SIGINT, self._exit_cleanup)
        signal.signal(signal.SIGQUIT, self._exit_cleanup)

    def alert_nagios(self, status=0):
        #TODO: Exit with exception, alert nagios
        pass

    def _exit_cleanup(self, signum, frame):
        self.logger.log("Received SIGNAL (%d). Exiting" %signum)

        try:
            self.logger.log("Cleaning up %s" %self.backup_file)
            os.unlink(self.backup_file)
            lock_file = self.backup_file + '.lock'
            if os.path.exitsts(lock_file):
                os.unlink(lock_file)
        except:
            pass
        sys.exit(2)

    def init_mb_object(self):
        status = True
        try:
            self.config = Config(consts.configfile) 
            self.config.read()
            self.logger = Logger(tag = self.config.syslog_tag, level = self.config.log_level)
        except Exception, e:
            self.config.syslog_tag = consts.SYSLOG_TAG 
            self.logger = Logger(tag = self.config.syslog_tag, level = self.config.log_level)
            self.logger.log("FAILED: Parsing config file (%s)" %(str(e)))
            status = False
        try:
            self.mb = MemcachedClient()
        except Exception:
            self.logger.log("FAILED: Could not initialize membase server connection")
            status = False
        return status

    def is_tap_registered(self):
        try:
            tap_stats = self.mb.stats('tap')
        except Exception:
            self.logger.log("FAILED: Could not fetch tap stats from membase server")
            self.exit(consts.ERROR_MEMBASE_CONNECTION_FAILED)

        if len(filter(lambda x: 'eq_tapq:%s:' %(consts.BACKUP_TAPNAME) in x, tap_stats)):
            return True
        return False


    def _lock_file(self, filepath):
        dirname = os.path.dirname(filepath)
        filename = os.path.basename(filepath)
        lock_file = os.path.join(dirname, '%s.lock' %filename)
        try:
            f = open(lock_file, 'w')
            f.close()
        except Exception, e:
            self.logger.log("Locking file %s failed (%s)" %(filepath, str(e)))
            return False
        return True

    def _unlock_file(self, filepath):
        dirname = os.path.dirname(filepath)
        filename = os.path.basename(filepath)
        lock_file = os.path.join(dirname, '%s.lock' %filename)
        try:
            os.unlink(lock_file)
        except Exception, e:
            self.logger.log("Unlocking file %s failed (%s)" %(filepath, str(e)))
            return False
        return True

    def create_backup(self):
        """
        Create incremental backup
        """
        status = self.init_mb_object()
        if status == False:
            return False

        self.logger.log("==== START BACKUP ====")
        now = time.localtime(time.time())
        datetimestamp = time.strftime('%Y-%m-%d %H:%M:%S', now)
        backup_filename = time.strftime('%Y-%m-%d_%H:%M:%S.incr.mbb',now) 
        start_time = time.time()

        self.logger.log("Creating Backup for %s" %(datetimestamp))

        if not self.is_tap_registered():
            self.logger.log("No registered TAP for Backup found")
            self.logger.log("FAILED: Creating Backup for %s" %(datetimestamp))
            return False

        backup_root = self.config.db_backup_root 
        backup_dir = os.path.join(backup_root, 'increments', self.hostprefix, self.hostname)
        if not os.path.exists(backup_dir):
            try:
                os.makedirs(backup_dir)
            except Exception, e:
                self.logger.log("FAILED: Creating Backup directory %s (%s)" %(backup_dir, e.strerror))
                self.logger.log("FAILED: Creating Backup for %s" %(datetimestamp))
                return False

        backup_filepath = os.path.join(backup_dir, backup_filename)
        self.backup_file = backup_filepath 

        self.logger.log("Creating Backup file : %s" %(backup_filepath))
        if not self._lock_file(backup_filepath):
            return False

        mbbackup_cmd = "%s -h %s:%d -o %s %s" %(consts.PATH_MBBACKUP_EXEC, "127.0.0.1", 11211, backup_filepath, consts.BACKUP_TAPNAME)
        status, msg = commands.getstatusoutput(mbbackup_cmd)
        
        size = 0
        if status > 0:
            self.logger.log("FAILED: %s" %msg)
            self.logger.log("FAILED: Creating Backup for %s" %(datetimestamp))
            if os.path.exists(backup_filepath):
                os.unlink(backup_filepath)
            self._unlock_file(backup_filepath)
            return False
        else:
            size = os.stat(backup_filepath).st_size
            if size == 0:
                self.logger.log("FAILED: Backup size is 0")
                os.unlink(backup_filepath)
                self.logger.log("FAILED: Creating Backup for %s" %(datetimestamp))
                self._unlock_file(backup_filepath)
                return False

        if not self._unlock_file(backup_filepath):
            return False
 
        end_time = time.time()
        time_taken = end_time - start_time
        self.logger.log("Completed Backup for %s" %(datetimestamp))
        self.logger.log("BACKUP SUMMARY: size: %d, time-taken: %d, backup-file: %s" %(size, time_taken, backup_filename))
        self.logger.log("==== END BACKUP ====")
        return True


if __name__ == '__main__':
    mb = MembaseBackup()
    mb.create_backup()

