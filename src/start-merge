#!/usr/bin/python26
#Description: Wrapper script that downloads, merges and uploads

import time
import os
import consts
import commands
from logger import Logger
from config import Config
import Queue
from threading import Thread
from util import natural_sortkey
import sys
import re
import getopt
import datetime
import fnmatch

DAY_EPOCH = 60*60*24
PID_FILE = '/var/run/merge_wrap.pid'

def epoch2date(epoch):
    lt = time.localtime(epoch)
    return time.strftime('%Y-%m-%d',lt)

class MergeWrapper:

    def __init__(self, location=None):
        try:
            self.config = Config(consts.CONFIG_FILE)
            self.config.read()
            self.logger = Logger(tag = self.config.syslog_tag, level = self.config.log_level)
        except Exception, e:
            self.config.syslog_tag = consts.SYSLOG_TAG
            self.logger = Logger(tag = self.config.syslog_tag, level = self.config.log_level)
            self.logger.log("FAILED: Parsing config file (%s)" %(str(e)))

        self.cloud = self.config.cloud
        self.game_id = self.config.game_id
        self.s3bucket = self.config.s3bucket
        now=datetime.datetime.now()
        self.timestamp = "%d:%d:%d-%d:%d" %(now.year,now.month,now.day, now.hour, now.minute)


    def _download_file(self, s3path, localpath=None):
        if localpath != None:
            get_cmd = "%s get %s %s" %(consts.PATH_S3CMD_EXEC, s3path, localpath)
        else:
            get_cmd = "%s get --force %s " %(consts.PATH_S3CMD_EXEC, s3path)
        retries = self.config.download_retries
        self.logger.log("Executing command %s" %get_cmd)
        for i in range(retries):
            if i > 0:
                self.logger.log("Retrying download for %s" %s3path)
            status, output = commands.getstatusoutput(get_cmd)
            self.logger.log("Downloading file %s " %(s3path))
            if status == 0:
                break

        if status !=0:
            self.logger.log("FAILED: %s" %output)
            return False
        else:
            self.logger.log("Completed downloading file %s" %s3path)
            return True

    def _delete_file(self, s3path):
        del_cmd = "%s %s %s " %(consts.PATH_S3CMD_EXEC, consts.DEL_COMMAND, s3path)
        retries = self.config.download_retries
        self.logger.log("Executing command %s" %del_cmd)
        for i in range(retries):
            if i > 0:
                self.logger.log("Retrying deletion for %s" %s3path)
            status, output = commands.getstatusoutput(del_cmd)
            self.logger.log("Deleting file %s " %(s3path))
            if status == 0:
                break

        if status !=0:
            self.logger.log("FAILED: %s" %output)
            return False
        else:
            self.logger.log("Completed deleting file %s" %s3path)
            return True


    def _upload_file(self, file, s3path, build_path=True):
        if build_path == False:
            put_cmd = "%s sync %s %s " %(consts.PATH_S3CMD_EXEC, file, s3path)
        else :
            put_cmd = "%s sync %s/%s %s " %(consts.PATH_S3CMD_EXEC, consts.BACKUP_ROOT, file, s3path + file)
        retries = self.config.download_retries
        self.logger.log("Executing command %s" %put_cmd)
        for i in range(retries):
            if i > 0:
                self.logger.log("Retrying upload for %s" %file)
            status, output = commands.getstatusoutput(put_cmd)
            self.logger.log("Uploading  file %s " %(file))
            if status == 0:
                break

        if status !=0:
            self.logger.log("FAILED: %s" %output)
            return False
        else:
            self.logger.log("Completed uploading file %s" %file)
            return True

    def _nuke_path(self, s3path):
        #create an empty directory
        empty_dir = "/tmp/nuke-%s" %self.timestamp
        if not os.path.exists(empty_dir):
            os.makedirs(empty_dir)
        nuke_cmd = "%s sync --delete-removed %s %s " %(consts.PATH_S3CMD_EXEC, empty_dir, s3path)
        retries = self.config.download_retries
        self.logger.log("Executing command %s" %nuke_cmd)
        for i in range(retries):
            if i > 0:
                self.logger.log("Retrying nuking for %s" %s3path)
            status, output = commands.getstatusoutput(nuke_cmd)
            self.logger.log("Nuking file %s " %(s3path))
            if status == 0:
                break

        if status !=0:
            self.logger.log("FAILED: %s" %output)
            return False
        else:
            self.logger.log("Completed nuking file %s" %s3path)
            return True

    def check_lock(self, s3path, upload_manifest=False, output_file=None):
        lock_file = consts.BACKUP_ROOT + "/.lock"
        self._download_file(s3path + ".lock", lock_file)
        status = os.path.isfile(lock_file)
        if status == True:
            os.system("rm " + lock_file)
            self.logger.log("WARNING: .lock file present. Skipping delete")
            #upload the manifest file to this location
            if upload_manifest == True and output_file != None:
                if self.manifest_file and os.path.isfile(self.manifest_file) :
                    #manifest file already exists. merge these two files and delete the old manifest
                    fd = open(self.manifest_file, "r")
                    fd2 = open(output_file, "a")
                    line = fd.readline()
                    while line:
                        fd2.write(line)
                        line = fd.readline()

                    fd.close()
                    fd2.close()
                    splits = self.manifest_file.split("/")
                    delete_file = filter(lambda x: x.endswith('.del'), splits)
                    status = self._delete_file(self.s3path + delete_file[0])
                    if status == False:
                        self.logger.log("FAILED to delete old manifest file %s" %delete_file[0])
                        return -1

                status = self._upload_file(output_file, self.s3path + "%s-manifest.del" %self.timestamp, False)
                if status == False:
                    self.logger.log("FAILED to upload manifest file %s to location %s" %(output_file, self.s3path))
                    return -1 # failure
                else:
                    return 1  # lock exists, skip delete
            return 1
        return 0              # no lock exists, clear to delete


    def cleanup_files(self, output_file=None):
        #parse the output and remove those files from the s3 bucket

        fd = open(output_file)
        line = fd.readline().strip()
        while line:
            status  = self._delete_file(line)
            if status != True:
                self.logger.log("Warning ! FAILED to delete file  %s" %line)
            line = fd.readline().strip()

        return True

    def upload_split(self) :
        #list all .mbb files in /dev/shm and upload them to daily backup location
        now=datetime.datetime.now()
        upload_location = "s3://%s/%s/%s/%s/daily/%d:%d:%d/" %(self.s3bucket, self.cloud, self.game_id, self.location, now.year, now.month, now.day)
        print "upload location %s" %upload_location
        for file in os.listdir(consts.BACKUP_ROOT):
            if fnmatch.fnmatch(file, '*.mbb'):
               status = self._upload_file(file, upload_location)
               if status != True:
                    #nuke the s3 location.
                    self._nuke_path(upload_location)
                    self.logger.log("FAILED to upload file %s for hostname %s" %(file, self.location))
                    return False
        # all done. Create a .done file in this location
        os.system("touch /dev/shm/.done")
        status = self._upload_file(".done", upload_location)
        if status == False:
            self.logger.log("FAILED to upload .done file for location %s" %upload_location)
            return False
        return True

    def download_split(self, s3path):
        splits = s3path.split("/")
        file = filter(lambda x: x.endswith('.mbb'), splits)
        status = self._download_file(s3path, consts.BACKUP_ROOT)
        if status == True:
            backup_file = consts.BACKUP_ROOT + "/" + file[0]
            #invoke the split command on this file
            strip_file = str(file[0]).split('.')
            split_file_names = consts.BACKUP_ROOT + "/" + strip_file[0] + '-%.mbb'
            split_cmd = "%s -o %s -m %d %s" %(consts.SPLIT_UPLOAD_CMD, split_file_names, consts.SPLIT_SIZE, backup_file)
            self.logger.log("Executing split command %s" %split_cmd)
            status,output = commands.getstatusoutput(split_cmd)

            if status == 0:
                os.system("rm " + backup_file)
            else:
                self.logger.log("FAILED to split : output %s" %output)
                return False

        if status == False:
            self.logger.log("FAILED to download incremental backup file %s" %s3path)
            return False

        return True


    def process_manifest(self, s3path):

        splits = s3path.split("/")
        file = filter(lambda x: x.endswith('.del'), splits)
        manifest_file = consts.BACKUP_ROOT + "/" + file[0]
        status = self._download_file(s3path, manifest_file)

        #check if the lock file exists.
        return_code = self.check_lock(self.s3path, False)
        if return_code == -1:
            self.logger.log("FAILED to check lock ")
            return False
        elif return_code == 1:
            # we might need to add to this file later
            self.manifest_file = manifest_file
            return True

        if status == True:
            status = self.cleanup_files(manifest_file)
            if status == False:
                self.logger.log("FAILED to cleanup manifest file %s" %manifest_file)
                return False
            status = self._delete_file(s3path)
            os.system("rm " + manifest_file)
            if status == False:
                self.logger.log("FAILED to delete manifest file %s" %manifest_file)
                return False
        else :
            self.logger.log("FAILED to download manifest file %s" %s3path)
            return False

        return True

    def _list_s3_files(self, s3path):
        ls_cmd = "%s ls %s" %(consts.PATH_S3CMD_EXEC, s3path)
        self.logger.log("Executing command %s" %ls_cmd)
        status, output = commands.getstatusoutput(ls_cmd)
        if status !=0:
            self.logger.log("FAILED: %s" %output)
            return False
        else:
            lines = output.split('\n')
            if lines == ['']:
                self.logger.log("WARNING: Empty incremental directory")
                return True
            for each_line in lines:
                word = each_line.split()
                #if size of file is greater than 1G download split and upload
                if word[3].find("-manifest") != -1 :
                    #delete manifest file exists.
                    status = self.process_manifest(word[3])
                if  int(word[2]) > (1024 * 1024 * 1024):
                    status = self.download_split(word[3])
                    if status == False:
                        return False
                    else:
                        for file in os.listdir(consts.BACKUP_ROOT):
                            if fnmatch.fnmatch(file, '*.mbb'):
                                status = self._upload_file(file, s3path)
                                if status == False:
                                    return False

                    #all spits uploaded. Now delete the large file
                    if os.path.isfile(self.manifest_file) :
                        #manifest file is present, add this file name to it and upload
                        fd = open(self.manifest_file, "a")
                        fd.write(word[3] + "\n")
                        fd.close()
                        status = self._upload_file(self.manifest_file, s3path, False)
                        if status == False:
                            self.logger.log("FAILED: unable to upload manifest file in _list_s3_files. %s" %self.manifest_file)

                    else:
                        status2 = self._delete_file(word[3])
                    if status2 == False:
                        self.logger.log("FAILED: unable to delete large backup file %s" %word[3])
                        status = status2
                    #cleanup all the mbb files
                    os.system("rm -rf " + consts.BACKUP_ROOT + "/*.mbb")
                #endif
            #endfor

        return status


    def merge_host(self, location=None):

        now=datetime.datetime.now()
        timestamp = "%d:%d:%d-%d:%d" %(now.year,now.month,now.day,now.hour,now.minute)
        merge_backupfile = "%s/%s-daily-%s" %(consts.BACKUP_ROOT,location,timestamp)
        output_file = "%s/%s-filelist-%s" %(consts.BACKUP_ROOT, location, timestamp)
        if self.manifest_file:
            merge_cmd = "%s -h %s -o %s -l %s -x %s" %(consts.MERGE_CMD,location,merge_backupfile, output_file, self.manifest_file)
        else:
            merge_cmd = "%s -h %s -o %s -l %s" %(consts.MERGE_CMD,location,merge_backupfile, output_file)
        print "executing command %s" %merge_cmd
        status, output = commands.getstatusoutput(merge_cmd)
        print "%s %s" %(output,status)
        done = False
        if status:
            self.logger.log("FAILED to merge backupfiles from location: %s" %location)
            return False
        else:
            self.logger.log(" Merge done for location %s" %location)
            split_file_names =  merge_backupfile + '-%.mbb'
            split_upload_cmd = "%s -o %s -m %d %s" %(consts.SPLIT_UPLOAD_CMD, split_file_names, consts.SPLIT_SIZE, merge_backupfile)
            print "Executing command %s" %split_upload_cmd
            status2,output2 = commands.getstatusoutput(split_upload_cmd)
            if status2:
                self.logger.log("FAILED to split and upload backup files: %s" %merge_backupfile)
                return False
            else:
                self.logger.log("Split done for file  %s timestamp %s" %(merge_backupfile,timestamp))
                ret_code = self.upload_split()
                if ret_code == True:
                    #check lock and upload manifest
                    return_code = self.check_lock(self.s3path, True, output_file)
                    if return_code == 0:
                        done = self.cleanup_files(output_file)
                    elif return_code == -1:
                        done = False
                    else:
                        done = True

                if done == False:
                    self.logger.log("FATAL: could not complete merge for host %s" %location)
                    return False
                print "Cleaning up backup root"
                os.system("rm -rf " + consts.BACKUP_ROOT + "/*")
                return True

    def main(self):

        if os.path.exists(PID_FILE):
            pid = int(open(PID_FILE, 'r').read())
            try:
                os.kill(pid, 0)
                self.logger.log("Merge process is already running with PID %d" %pid)
                os._exit(1)
            except:
                pass
        fd = open(PID_FILE,'w')
        fd.write(str(os.getpid()))
        fd.close()

        #download the bootstrap file from the s3 location
        hostname = str(os.uname()[1])
        filepath = "s3://%s/hostinfo-%s"%(consts.MBA_BOOTSTRAP_PATH,hostname)
        status = self._download_file(filepath)

        print "Cleaning up backup root"
        os.system("rm -rf " + consts.BACKUP_ROOT + "/*")
        if status != True:
            self.logger.log("FAILED to download bootstrap file")
            return False
        else:
            fd = open("hostinfo-%s"%hostname,'r')
            line = fd.readline().strip()
            while line:
                self.location = line
                self.manifest_file = None
                self.s3path = "s3://%s/%s/%s/%s/%s/" %(self.config.s3bucket, self.cloud, self.game_id, line, consts.INCR_DIRNAME)
                self._list_s3_files(self.s3path)
                status = self.merge_host(line)
                if status != True:
                    self.logger.log("FAILED to merge backup files from host %s" %line)
                line = fd.readline().strip()


if __name__ == '__main__':
    if len(sys.argv) != 1:
        print
        print "Usage: %s <hostame list location>" %sys.argv[0]
        sys.exit(1)

    merge = MergeWrapper()
    merge.main()
